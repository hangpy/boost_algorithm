

# 알고리즘 카테고리

문제를 풀면서 반복적으로 실수할 가능성이 높은 부분은 반드시 정리하고 실수를 반복해선 안된다. 



<br>

<br>

<br>

## &#128297; 컴파일 환경

**MS Visual Studio**

<br>

<br>

<br>

## &#128518; 실수 모음

[BFS 중복 카운트 실수](./BAEK_2667#실수한-부분)

[인접리스트 방향성 고려](./BAEK_2606#실수한-부분)

[고정된 크기의 입력값을 받을 때](./BAEK_10216#실수한-부분)

[시간, 메모리 제약사항 부터 확인](./BAEK_1890#실수한-부분)

[정답의 크기를 고려한 자료형 선언](./BAEK_1890#출력-형태의-자료형을-반드시-확인하라)

[종료 시점을 로직에 포함 여부 고려](./BAEK_1890#로직이-종료되는-순간의-조건을-항상-생각한다)

[필요 없는 계산은 피하기](./BAEK_1890#필요-없는-계산은-시간-효율을-위해-시키지-않는다)

[비교연산자 대상체 실수하지 말 것](./BAEK_1504#실수한-부분)

[입출력 제약사항 반드시 확인할 것](./BAEK_1504#실수한-부분)

[비어있는 queue에서 계속 front(), pop() 시도](./BAEK_3190#실수한-부분)

<br>

<br>

<br>

## &#128526; C++ 기법 모음

시간을 줄이기 위한 scanf 표준 입출력 사용 (예정) (scanf, cin 상황별 사용 요령)

C++에서 무한대 표현하기 (예정)

소수점 밑 반올림 (예정)

우선순위 큐 (priority_queue) 활용 방법 및 중복 방지 (예정)

순열조합, 중복순열 표현하기 (예정)

묶고 싶은 것은 구조체(struct)를 사용하자 (예정)

방향성 표현하기 (예정)

컨테이너속 노드에 구조체를 통해 상태 추가하기 (예정)

정렬하는 방법. STL 활용법 숙지 (예정)

<br>

<br>

<br>

## &#128534; 에러별  대처 모음

[Expression: deque iterator not dereferencable](./errors#Queue가-비어있는데-참조를-시도할-때) (예정)

<br>

<br>

<br>

## &#127813; DFS, BFS

[BEAK 2606. 바이러스](./BAEK_2606)

[BEAK 2667. 단지번호붙이기](./BAEK_2667)

[BAEK 10216. Count Circle Groups](./BAEK_10216)

[BAEK 1890. 점프](./BAEK_1890) (풀 수는 있지만 DFS, BFS로 풀 경우 각각 시간, 메모리 제한 초과)

[BAEK 1325. 효율적인 해킹](./BAEK_1325)

[BAEK 3055. 탈출](./BAEK_3055)

<br>

<br>

<br>

## &#127817; DP

[BAEK 1890. 점프](./BAEK_1890)

[BAEK 9095. 1, 2, 3 더하기](./BAEK_9095)

<br>

<br>

<br>



## &#127816; Simulation

[BAEK 3190. 뱀](./BAEK_3190)

<br>

<br>

<br>



## &#127820; Greedy

 [BAEK 2217. 로프](./BAEK_2217)

<br>

<br>

<br>



## &#127821; 위상정렬

[BAEK 1516. 게임개발](./BAEK_1516)

<br>

<br>

<br>



## &#127815; 최단경로 문제 (SSP, ASP)

[BAEK 1504. 특정한 최단 경로 (다익스트라)](./BAEK_1504)

[BAEK 11657. 타임머신 (벨만 포드)](./BAEK_11657)

<br>

<br>

<br>



## &#127826; 문자열 처리

[BAEK 3613. Java vs C++](./BAEK_3613)

<br>

<br>

<br>