

### &#128526;[문제 링크](https://www.acmicpc.net/problem/2606)

<br>

<br>

<br>

## 접근법

**인접리스트**를 사용한 **DFS**로 접근. 노드 간의 탐색을 하는 가장 기초적인 DFS문제이다. 여러가지 방법이 있을 수 있겠지만 인접리스트를 사용하는 것이 메모리 적으로나 시간복잡도 면에서 유리하다. 다음 문제와 같이 입력이 노드 간의 쌍으로 되어 있다면 인접리스트를 사용하는 것이 특히 더 유용하다.

<br>

<br>

<br>

## 핵심 파트

```C++
int dfs(int node)
{
    // 가장 끝단의 재귀 함수에서 더이상 방문할 노드가 없을 경우의 카운트를 위함
	int ans = 1;
    // dfs를 통해 들어오면 일단 방문한 것으로 체크한다
	V[node] = 1;
	for (auto i : adj[node])
        // 재귀로터 반환된 값들을 축적한다
		if (!V[i]) ans += dfs(i);		
	return ans;
}
```

여기서 눈여겨 볼 부분은 `int`를 반환함으로써 바로 답을 도출했다. `ans`를 1로 초기화 할 경우 재귀를 통해 더이상 방문할 노드 없으면 1을 직전 재귀호출자에게 반환함으로써 방문한 노드의 개수를 축적한다. `방문 가능한 노드`와 같이 카운트할 때 유용한 방법이다. 마지막이 본인을 포함하느냐 아니냐는 최종 답 도출 후 1을 빼주느냐 안빼주느냐로 결정할 수 있다.

<br>

<br>

<br>

### 실수한 부분

#### 실수

```c++
for (int i = 1; i <= P; i++)
{
    int x, y;
    cin >> x >> y;
    adj[x].push_back(y);
}
```

인접리스트를 사용할 때 저지르기 쉬운 실수이다. 이와 같은 형태의 인접리스트 구성은 결론적으로 `방향`을 고려한 그래프라고 볼 수 있다. 예를들어

```
1 2
2 3
1 5
5 2
5 6
4 7
```

예제 입력과 같이 다음과 같은 입력을 위의 실수한 코드로 그래프를 구성한다면 이는 `연결 방향`을 가진 그래프가 되느 것이다. 위의 입력 예제에서 구성한 그래프에서는 1에서 2로 갈 수 있지만 2에서 1로 갈 수는 없다. 이럴 경우 다음과 같은 입력 케이스가 들어올 경우 오답을 도출하게 된다.

```
1 2
2 3
1 5
5 2
5 6
4 7
7 6 /**/
```

왜냐면 아래와 같은 상황에서 7과 6이 연결되면, 1로부터 감염될 수 있는 노드의 수는 6으로 답이 도출되어야 한다.  

![](https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png)

하지만 실수한 코드에서는 오로지 7에서 6으로만 갈 수 있다. 즉 인접리스트에서 6에는 7이 없다. 이는 `dfs` 재귀 호출 시 6에서 더이상 방문할 노드가 없다는 의미이다. 즉, 연결이 되어있음에도 6에서 7로 이동할 수 없기 때문에 답이 6이 아니라 4가 나오게 된다. 때문에, `방향성`을 고려해서는 안되는 그래프를 표현하기 위해서는 아래와 같은 형태로 반드시 인접 리스트를 구성해야 한다.

<br>

#### 실수 고친 후

```c++
for (int i = 1; i <= P; i++)
{
    int x, y;
    cin >> x >> y;
    adj[x].push_back(y);
    adj[y].push_back(x); /*추가*/
}
```



<br>

<br>

<br>

