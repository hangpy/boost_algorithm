

### &#128526;[문제 링크](https://www.acmicpc.net/problem/1890)

<br>

<br>

<br>

## 접근법

처음에는 DFS, BFS로 각각 접근. 이렇게 풀 경우 모두 매우 빠른 속도로 구현과 답 도출이 가능 했지만 안타깝게도 시간 및 메모리 제한을 지키지 못했다. DFS로 풀 경우, 함수 호출 시간과, 중복된 노드의 계산이 시간 초과를 야기 했다. BFS같은 경우, 중복된 노드가 queue에 너무 많이 들어감에 따라 메모리 제한을 초과했다. 이경우, 중복된 노드를 다루는 것을 방지할 `DP with Memoization`이 필요했다.

`DP`는 작은 단위의 문제로 나누어 생각해 보는 것이다. 키 포인트는 특정 노드로의 경로는 두 방향으로 부터 온 노드가 가지고 있는 각 노드의 총 합이다. 즉, `dp[101][101]` 이라는 이차원 배열을 선언과 동시에 0으로 초기화 한 뒤 `(1, 1)`에만 1을 대입한다. 이렇게 할 경우, `for`문을 돌면서 도달할 수 없는 노드는 0으로 남아 있을 것이고, 도달 가능한 노드는 이전의 노드로부터의 경로 개수가 축적되면서 최종적으로 목적지 위치에 우리가 원하는 답이 있을 있는 것이다.

<br>

<br>

<br>

## 핵심 파트

```C++
dp[1][1] = 1;
for (int row = 1; row <= N; row++)
{
    for (int col = 1; col <= N; col++)
    {
        int len = BOARD[row][col];

        //  이부분을 추가 안하게 되면 오답이 도출, 필요 없는 계산은 건너 뛰기!
        if (BOARD[row][col] == 0 || dp[row][col] == 0) continue;

        if (row + len <= N)
            dp[row + len][col] += dp[row][col];
        if (col + len <= N)
            dp[row][col + len] += dp[row][col];
    }

}
cout << dp[N][N] << endl;
```

#### 꿀팁 &#128273;

```c++
// only two direction: right or below
int drow[2] = { 1, 0 };
int dcol[2] = { 0, 1 };
```

보통 위와 같이 집합으로 두고 `for`문을 돌리는 형태로 이동을 하는데, 해당 문제와 같이 고작 두방향이고 그 형태가 단순하며 DFS나 BFS와 같이 그 방향으로 진입하지 않는 경우 굳이 집합을 사용하지 않는게 구현시간을 줄이는데 도움이 된다.

<br>

<br>

<br>

## 실수한 부분

#### 시간, 메모리 제한을 반드시 먼저 확인하자

| 시간 제한 | 메모리 제한 |
| :-------- | :---------- |
| 1초       | 128MB       |

해당 문제가 BFS, DFS 분류에 있긴 했으나, 평소 푸는식으로 푼다면 위와 같은 제한을 만족하기는 어렵다. [Count Circle Groups](https://www.acmicpc.net/problem/10216)와 같은 문제의 경우 Test Case와 함께 그 입력 값이 큰 경우 충분한 시긴과 메모리가 주어지지만, 해당 문제의 경우, 최악의 경우 시간복잡도가 $2^N$ 이다. 입력의 최대 크기는 100이므로 $2^100$이 되는데, 당연히 제한 시간내에 풀 수 없게 된다. 아래와 같이 제약사항이 주어지면 얘기가 다르다.

| 시간 제한 | 메모리 제한 |
| :-------- | :---------- |
| 8초       | 256MB       |

딱봐도 컴퓨터로 돌리기에 시간이 꽤 남는 듯한 시간이 주어지면 보통은 완전탐색으로 해도 큰 무리는 없는 문제일 확률이 높다. 문제를 풀 때 반드시 시간, 메모리 제약사항을 확인하자.

> *시간, 메모리 제약사항을 통해 어떻게 접근해야 할지 윤곽히 잡힐 수 있다.*

<br>

#### 출력 형태의 자료형을 반드시 확인하라

그렇지 않으면 의도치 않은 결과가 나올 확률이 높음.

`경로의 개수는 $\2^63-1$보다 작거나 같다.`

마지막에 다음과 같은 조건이 추가되었다. 분명히 의미 있는 문장이기에 다음과 같은 조건이 추가된 것일거라는 생각을 해야한다. 이럴 때 가장 먼저 해야하는 생각은 다음과 같다.

> ***정답 출력에 반드시 `$2^63-1$ ` 까지는 표현이 가능한 자료형을 써야하겠구나!***

때문에 해당 문제에서는 정답 출력을 위한 변수를 선언할 때 자료형을 반드시 `int`가 아닌 `singed 64bit를 지원하는  `long long`으로 해야 한다. 간과하기 쉬운 부분이나 찾아내지 못하면 치명적일 수 있는 부분이다.

[C++의 모든 자료형](http://melonicedlatte.com/algorithm/2018/03/04/022437.html)

<br>

#### 로직이 종료되는 순간의 조건을 항상 생각한다

```c++
if (BOARD[row][col] == 0 || dp[row][col] == 0) continue;
```

처음에 `BOARD[now][col] == 0` 일 경우 무시하는 조건을 추가하지 않았을 때, 문제에서 제공하는 `input`예시의 답이 `12`가 나와서 한참동안 맞는 접근법임에도 불구하고 틀린 것이라 생각했다. 여기서 12가 나온 이유는 다음과 같다. 마지막 목적지에 도착해서도 위와 같은 조건이 없어서 `continue` 다음의 로직이 목적지 에서도 실행이 됐던 것이다. 그 상태에서 길이가 0이므로 자기 자신에 대한 계산을 두 번 더하게 된 것이다. 즉 `3`에서 자기 자신을 축적해서 `6`이 되고, 다시 `col+len`에 대한 계산을 함으로써 `6 + 6 = 12`이 되어 오답이 출력 된것이다.

해당 문제와 같이 `종료 시점`이 존재하는 문제에서는 반드시 `종료 시점`에서의 상황을 로직에서 `포함`관계를 잘 생각해야한다.

> *로직에서 **목표지점 포함 여부**를 반드시 체크한다.*

<br>

#### 필요 없는 계산은 시간 효율을 위해 시키지 않는다

```c++
//  이부분을 추가 안하게 되면 오답이 도출, 필요 없는 계산은 건너 뛰기!
if (BOARD[row][col] == 0 || dp[row][col] == 0) continue;
```

위의 핵심 파트에서 도달할 수 없는 셀은 굳이 계산할 필요가 없다. 다음과 같은 조건을 추가하면 그 뒤의 필요없는 계산을 하지 않아도 된다.



<br>

<br>

<br>

