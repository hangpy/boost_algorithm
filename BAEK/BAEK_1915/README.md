

### &#128526;[문제 링크](https://www.acmicpc.net/problem/1915)

<br>

<br>

<br>

## 시간

약 50분. 금방 풀긴 했지만 생각해낸 알고리즘의 소요 시간이 너무 오래걸림. 다시 생각했어야 함.

처음: `424ms`, `8928KB`

재풀이: `12ms`, `6880KB`

<br>

<br>

<br>

## 접근법

좋지 않은 시간복잡도의 처음 접근법은 일단 입력부터 문자열이 연속된 0101 숫자를 한자리 숫자씩 받아 배열에 넣는 것이었다. 이후 오른쪽 아래의 모서리를 기준으로 정사각형을 dp형식으로 찾아나가면 중복된 계산을 피할 수 있을 것이라고 생각.

여기까진 입력 부분 말고는 좋았으나 그 다음이 문제였음. 나는 왼쪽 대각선이 0이 아닐경우, 해당 숫자만큼 위, 왼쪽으로 탐색해서 0이 나오지 않는다면 왼쪽 대각선의 값 + 1이라는 값을 dp의 해당 이중 배열위치에 삽입했음. 결과적으로는 맞긴 했지만 입력부분과 위와같은 너무 빙빙 돌아가는 알고리즘으로 인해 좋지 못한 시간 결과가 나옴. 

이 후 찾아본 다른 사람들의 방식은 아래의 코드와 같았음.

왼쪽, 왼쪽 위 대각선, 위, 세 점의 정사각형 모양을 동시다발적으로 발상했다면 아래와 같이 할 수 있었을텐데, 좀 더 직관적으로 접근하는 연습이 필요할 듯 함.

<br>

<br>

<br>

## 코드

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int N, M, dp[1001][1001];
char map[1001][1001];

int main()
{
	ios::sync_with_stdio(0); cin.tie(0);
	cin >> N >> M;
	// 문제에서는 숫자를 제시하지만 받을 때는 문자열로!
	for (int n = 0; n < N; n++) cin >> map[n];
	
	int MAX = 0;                                                    
	for (int y = 0; y < N; y++)
	{
		for (int x = 0; x < M; x++)
		{
			if (map[y][x] != '1') continue;
			// 사전에 구해진 인접한 왼쪽, 왼쪽 대각선, 위쪽의 값 중 최소값 선택.
			else dp[y + 1][x + 1] = min(dp[y][x], min(dp[y + 1][x], dp[y][x + 1])) + 1;

			MAX = max(MAX, dp[y+1][x+1]);
		}
	}
	cout << MAX * MAX << "\n";
	return 0;
}
```

<br>

<br>

<br>